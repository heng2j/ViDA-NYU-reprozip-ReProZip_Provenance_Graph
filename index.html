<!DOCTYPE html>
<meta charset="utf-8">

<body>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://momentjs.com/downloads/moment.js"></script>
<link rel="stylesheet" href="style.css">

<!-- Planing to switch to d3 v4 if necessary
<script src="https://d3js.org/d3.v4.min.js"></script>
-->
<script src="//d3js.org/d3.v3.min.js"></script>

<div id="mySidenav" class="sidenav">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>

    <div id='notes' class="fileSearch">
        <h4 style="margin-top: 25px; font-size: 15px">Please select a process</h4>

    </div>

</div>


<div id='container'>
    <div id='sidePanel'>

        <div id = 'jsonSelections'></div>



        <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; Process Info</span>
    </div>


    <div id='viz-graph'></div>

</div>

<script>
    //script for Sidebar
    function openNav() {
        document.getElementById("mySidenav").style.width = "20%";
        document.getElementById("viz-graph").style.marginLeft = "20%";
    }

    function closeNav() {
        document.getElementById("mySidenav").style.width = "0";
        document.getElementById("viz-graph").style.marginLeft= "0";
    }
</script>

<script>

    // script to prepare data
    var fileDict = {};
    var rawData = [] ;
    var treeData = [];
    var forceNodes = {"nodes" : []};

</script>


<script>

    // script for visualization

    //var currentJsonFile = "bash-count.json";
    //var currentJsonFile = "stacked-up-website.json";
    var currentJsonFile = "ache.json";


    var availableJsonFiles = ["bash-count.json", "stacked-up-website.json", "ache.json"];

    var forceData = {"packages": []};

    var force = d3.layout.force();
    //var links = force.links();


    var packagesNumber = 0;

    var isTreeRedrawn = false;

    // add the tool tip
    var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);


    var margin = {top: 20, right: 120, bottom: 20, left: 100},
        width = 4500 - margin.right - margin.left,
        height = 1100 - margin.top - margin.bottom,
        padding = 3.5, // separation between same-color nodes
        maxRadius = 20 // radious for each package ;

    var timeLineLen;
    var timeLineLen_Total;
    var duration_total_ms;

    var searchFilesInfoDiv;
    var searchFilesList;

    var i = 0,
        duration = 750,
        rootStartTime,
        root,
        m = 15; // number of distinct clusters;



    var tree = d3.layout.tree()
        .size([height , width + 100]);




    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("#viz-graph").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Select the container for the notes and dimension it.
    var notes = d3.select('#notes')
        .style({
            'width': 620-width + 'px',
            'height': height + 'px'
        });




    var edge = svg.selectAll(".edge");

    treeDraw(currentJsonFile);


    var select = d3.select('#jsonSelections')
        .append('select')
        .attr('class','select')
        .attr("x", 400)
        .on('change',function onchange() {
            selectValue = d3.select('select').property('value');

            currentJsonFile = selectValue;

            treeDraw(currentJsonFile);

            isTreeRedrawn = true;
        });


    var options = select
        .selectAll('option')
        .data(availableJsonFiles).enter()
        .append('option')
        .text(function (d) { return d; });

    d3.select(self.frameElement).style("height", "800px");


    // update Tree function
    function update(source) {




        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
            links = tree.links(nodes);


        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 180; });

        // Update the nodes…
        var node = svg.selectAll("g.node")
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("dblclick", dblclick)
            .on("click", click)
            .on("mousedown", function(d){

                d3.select("body").transition().style("background-color", "#1c1c1c");

            })
            .on("mouseup", function(d){

                console.log("mouseUP");
                d3.select("body").transition().style("background-color", "white");

            })
            .on("mouseover", function(d) {

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .8);
                tooltip .html(
                    d.description
                )
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 38) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });

        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter.append("text")
            .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);


        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function(d) {



                return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate.select("circle")
            .attr("r", 8)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit.select("circle")
            .attr("r", 1e-6);

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);

        // Update the links…
        var link = svg.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            });


        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();


        // Update the link text
        var linktext = svg.selectAll("g.link")
            .data(links, function (d) {
                return d.target.id;
            });

        //  console.log('linktext',linktext);


        linktext.enter()
            .insert("g")
            .attr("class", "link")
            .attr("transform", function(d) { return "translate(" + d.source.y + "," + d.source.x + ")"; })
            .append("text")
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .style("font-size", 15)
            .text(function (d) {
                return d.target.rule;
            });

        // Transition link text to their new positions

        linktext.transition()
            .duration(duration)
            .attr("transform", function (d) {
                return "translate(" + ((d.source.y + d.target.y) / 2) + "," + ((d.source.x + d.target.x) / 2) + ")";
            })


        //Transition exiting link text to the parent's new position.
        linktext.exit().transition()
            .remove();


        // Stash the old positions for transition.
        nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function dblclick(d) {

        var duration;

        if (d.children) {


            d._children = d.children;
            d.children = null;

            decreaseTimeLineLen(d.y );

            console.log('Close');

            duration = (d.start_time - rootStartTime) / 1000000;


        } else {


            d.children = d._children;
            d._children = null;

            console.log('Open');



            var tempDuration = 0;


            if (d.children != null){

                d.children.forEach(function(node) {

                    if ((node.start_time - rootStartTime) > tempDuration) {

                        tempDuration = node.start_time - rootStartTime;
                    };


                });
            }
            else{
                tempDuration = d.exit_time - rootStartTime;

            }


            duration = tempDuration / 1000000;  //d.children[0].start_time - rootStartTime;


        }

        timeLineLen =  timeLineLen_Total * (duration / duration_total_ms);

        //  var durationLabel  = "Took " + (duration / 1000000).toFixed(2) + " milliseconds";

        updateTimeLine(timeLineLen, getTimeLineLabel(duration));



        update(d);
    }


    // Toggle children on click.
    function click(d) {



        console.log('single click');



        var links = force.links();

        links = [];
        //edge = [];

       // console.log("edge before:  ", edge.innerHTML);

        var edge = svg.selectAll(".edge").data(links);

        var edgeExit = edge.exit().remove();


        if(force.nodes().length > packagesNumber){

            console.log('single click force.nodes() before pop', force.nodes());

            force.nodes().pop();

                console.log('single click force.nodes() after pop', force.nodes());

        }


        //        var node = {};
        //        node.x = 100;
        //        node.y = 100;
        //        node.cx = 100;
        //        node.cy = 100;
        //        node.px = 100;
        //        node.py = 100;
        //        node.weight = 10;
        //        node.style =
        //            ("fill" , function() {
        //                return "hsl(" + Math.random() * 360 + ",60%,80%)";
        //            });
        //        node.radius = 20;
        //
        //
        //
        //
        //
        //        var node2 = {};
        //        node2.x = 100 + 100;
        //        node2.y = 100 + 100 ;
        //        node2.cx = 100 + 100;
        //        node2.cy = 100 + 100 ;
        //        node2.px = 100 + 100;
        //        node2.py = 100 + 100;
        //        node2.weight = 10;
        //        node2.style =
        //            ("fill" , function() {
        //                return "hsl(" + Math.random() * 360 + ",60%,80%)";
        //            });
        //
        //        node2.radius = 20;
        //
        //        var nodes = force.nodes();
        //        nodes.push(node);
        //        nodes.push(node2);
        //
        //        links.push({source: node, target: node2});
        //
        //
        //        console.log('links:', links);
        //        console.log('force.nodes():', force.nodes());
        //


        //console.log('restart after links: ', links);



        var circles = svg.selectAll(".package");

        console.log('click circles: ', circles);

        // add links to any nearby nodes

        var node = {};
        node.x = d.y;
        node.y = d.x;
        node.px = d.y;
        node.py = d.x;
        node.weight = 10;
        node.style =
            ("fill" , function() {
                return "hsl(" + Math.random() * 360 + ",60%,80%)";
            });
        node.radius = 20;


        console.log('click circles before push nodes: ', force.nodes());

        force.nodes().push(node);

        console.log('click circles after push nodes: ', force.nodes());

        console.log('click circles before push links: ', links);


        force.nodes().forEach(function(target) {

            d.packages.reads.forEach(function (readFile) {

                if(target.name == readFile){


                    links.push({source: node, target: target});
                }

            })



        });

        console.log('click circles after push links: ', links);



        var edgeEnter = edge.data(links).enter().insert("line", ".package")
            .attr("class", "edge")
            .attr("x1", function(d){ console.log("mapping link"); return d.source.x;
            })
            .attr("y1", function(d){ return d.source.y; })
            .attr("x2", function(d){ return d.target.x; })
            .attr("y2", function(d){ return d.target.y; });

       // console.log("edge after:  ", edge.innerHTML);



        force.start();


//
//           console.log('single click force.nodes()', force.nodes());
//
//
//          console.log('single click force.nodes().length', force.nodes().length);
//
//          console.log('single click packagesNumber', packagesNumber);
//
//            console.log('single click forceData.packages: ', forceData.packages);




        // Delete the current links section to prepare
        // for new links.


        //force.links().exit().remove();

        // var link = svg.selectAll(".edge");



        // restart();





        // Delete the current notes section to prepare
        // for new information.

        notes.selectAll('*').remove();

        var commands = '';


        if(d.argv != null){

            d.argv.forEach(function(argv){

                commands += argv;//.concat(argv.toString());
                commands += ' ';

            });
        }
        else{

            commands = 'No argument for this process'
        }


        // Fill in the notes section with informationm
        // from the node. Because we want to transition
        // this to match the transitions on the graph,
        // we first set it's opacity to 0.

        notes.style({'opacity': 0});
        // Now add the notes content.


        //  var readFromDivHeader = notes.append('div').attr("id", "readFromDivHeader").attr("class", "panel-heading");
        notes.append('h3').text("Process:").attr("href", "#ProcessName").attr("class", "panel-title").attr("data-toggle", "collapse").style({'padding-left': 0, 'font-size': '24px','text-decoration': 'none', 'color':'black' });
        notes.append('h5').text(d.name).attr("id", "ProcessName" ).attr("class", "panel-collapse "); //.style({'padding-left': 0, 'text-decoration': 'none', 'color':'black' });


        notes.append('h3').text("Commands:").attr("href", "#Commands").attr("class", "panel-title").attr("data-toggle", "collapse").style({'padding-left': 0, 'font-size': '24px','text-decoration': 'none', 'color':'black' });
        notes.append('h5').text(commands).attr("id", "Commands" ).attr("class", "panel-collapse ");

        notes.append('h3').text("Associated Files:").style({'padding-left': 0, 'text-decoration': 'none' ,'color':'black'});

        notes.append('input').attr("type", "search").attr("class", "fileSearch_input").attr("placeholder", "Search for listing files")
            .style("margin-left", "10px;");

        searchFilesInfoDiv = notes.append('div').attr("class", "searchFilesInfoDiv");

        searchFilesList = notes.append('div').attr("class", "searchFilesList");


        var filesList = [];

        var fileNamesList = d.reads.sort().concat(d.writes.sort());

        fileNamesList.forEach(function(file){


            var keyName = "\"" + file + "\"";

            if(keyName in fileDict){


                var file = fileDict[keyName];

                filesList.push(file);

            }


        });



        var filelistUL = searchFilesList.append('ul');
        var fileCount = 1;

        filesList.forEach(function(file){

            var id = "faq-" + fileCount;
            var href = "#" + id;

            var fileLi =   filelistUL.append('li').attr("id",id );

            var fileH2 =  fileLi.append('h4');//.text(file.name);
            var fileA =  fileH2.append('a').attr("href", href).text(file.name);

            var fileDiv = fileLi.append('div');



            var proccess_Read = "";
            var proccess_Write = "";


            if(file.reads.length != 0){
                file.reads.forEach(function(process){
                    proccess_Read += process + "<br/>"

                });
            }
            else {

                proccess_Read = "Not read by any process."
            }

            if(file.writes.length != 0){
                file.writes.forEach(function(process){
                    proccess_Write += process + "<br/>"

                });
            }
            else {

                proccess_Write = "Not written by any process."
            }

            fileDiv.html(
                "<br>" +
                "<h5>From Package:  " +  file.package+ " </h5>" +

                "<h5>Read By: </h5>" +
                proccess_Read
                +
                "<br>"
                +
                "<h5>Written By: </h5>" +
                proccess_Write

            )



            fileCount++;

        });


        searchFilesList.append('div').attr("class", "searchFilesList__notfound").html(
            "<p>No matches were found&hellip; Try &ldquo;bash&rdquo;.</p>"

        );


        // associationString: "reads" or  "writes
        createFileTooTip(searchFilesInfoDiv,d,"reads");
        createFileTooTip(searchFilesInfoDiv,d,"writes");

        searchFilesInfoDiv.append('h3').text("Associated Packages:").style({'padding-left': 0, 'text-decoration': 'none' ,'color':'black'});


        createPackageTooTip(searchFilesInfoDiv,d);



        // With the content in place, transition
        // the opacity to make it visible.

        notes.transition().style({'opacity': 1});


        'use strict';


        // search & highlight

        ;( function( $, window, document, undefined )
        {
            var $container = $( '.fileSearch' );
            var $searchFilesListContainer = $container.find( '.searchFilesList' );

            if( !$container.length ) return true;


            var $input			= $container.find( '.fileSearch_input' ),
                $notfound		= $searchFilesListContainer.find( '.searchFilesList__notfound' ),
                $items			= $searchFilesListContainer.find( '> ul > li' ),
                $item			= $(),
                itemsIndexed	= [];

            console.log("searchFilesListContainer:", $searchFilesListContainer);


            $items.each( function()
            {
                itemsIndexed.push( $( this ).text().replace( /\s{2,}/g, ' ' ).toLowerCase() );
            });

            $input.on( 'keyup', function( e )
            {
                console.log('keyup : ');

                $(".searchFilesInfoDiv").hide();
                $(".searchFilesList").show();


                if( e.keyCode == 13 ) // enter
                {

                    $input.trigger( 'blur' );
                    return true;
                }

                $items.each( function()
                {
                    $item = $( this );
                    $item.html( $item.html().replace( /<span class="highlight">([^<]+)<\/span>/gi, '$1' ) );
                });

                var searchVal = $.trim( $input.val() ).toLowerCase();
                if( searchVal.length )
                {
                    for( var i in itemsIndexed )
                    {
                        $item = $items.eq( i );
                        if( itemsIndexed[ i ].indexOf( searchVal ) != -1 )
                            $item.removeClass( 'is-hidden' ).html( $item.html().replace( new RegExp( searchVal+'(?!([^<]+)?>)', 'gi' ), '<span class="highlight">$&</span>' ) );
                        else
                            $item.addClass( 'is-hidden' );
                    }
                }
                else {
                    $items.removeClass('is-hidden');

                    $(".searchFilesInfoDiv").show();
                    $(".searchFilesList").hide();

                }

                $notfound.toggleClass( 'is-visible', $items.not( '.is-hidden' ).length == 0 );
            });
        })( jQuery, window, document );


        // toggling items on title press

        ;( function( $, window, document, undefined )
        {
            $( document ).on( 'click', '.searchFilesList h4 a', function( e )
            {
                e.preventDefault();
                $( this ).parents( 'li' ).toggleClass( 'is-active' );
            });
        })( jQuery, window, document );


        // auto-show item content when show results reduces to single

        ;( function( $, window, document, undefined )
        {
            var $container = $( '.fileSearch' );
            var $searchFilesListContainer = $container.find( '.searchFilesList' );

            if( !$container.length ) return true;

            var $input			= $container.find( '.fileSearch_input' ),
                $items			= $searchFilesListContainer.find( '> ul > li' ),
                $item			= $();

            $input.on( 'keyup', function()
            {
                $item = $items.not( '.is-hidden' );
                if( $item.length == 1 )
                    $item.addClass( 'js--autoshown is-active' );
                else
                    $items.filter( '.js--autoshown' ).removeClass( 'js--autoshown is-active' );
            });
        })( jQuery, window, document );


    }


    function createFileTooTip(notesDiv,source, associationString){


        var readsList;
        var idString;
        var idString_href;
        var text_String ;

        if(associationString == 'reads'){

            idString = "readsToDiv";
            idString_href = "#readsToDiv";
            text_String = "Reads from:";
            readsList = source.reads.sort();
        }
        else if (associationString == 'writes'){

            idString = "writesToDiv";
            idString_href = "#writesToDiv";
            text_String = "Writes to:";
            readsList = source.writes.sort();

        }



        notesDiv.append('h5').attr("class", "panel-title").append('a').attr("data-toggle", "collapse").attr("href", idString_href).text(text_String).style({'padding-left': 0, 'text-decoration': 'none', 'font': '8 px sans-serif' });

        var readsFromDiv = notesDiv.append('div').attr("id", idString ).attr("class", "panel-collapse ");

        // var readsList = source.writes.sort();
        var packagePath = '';
        var newDetails ;
        var newSummary;
        var currentUL ;


        if(readsList.length !=0){

            for (var i = 0; i < readsList.length; i++ ){

                packagePath = setPackagePath(readsList, i , i + 1);
                newDetails = readsFromDiv.append('details');
                newSummary = newDetails.append('summary').text(packagePath);
                currentUL = newDetails.append('ul');

                while(readsList[i].includes(packagePath) ){


                    var thisReadArray = ["\"" + readsList[i] + "\""];

                    var fileName = readsList[i].replace(packagePath,"");

                    currentUL.append('li')
                        .data(thisReadArray)
                        .on("mouseover", function(d) {


                            var thisFile =  fileDict[d];

                            var proccess_Read = "";
                            var proccess_Write = "";


                            if(thisFile.reads.length != 0){
                                thisFile.reads.forEach(function(process){
                                    proccess_Read += process + "<br/>"

                                });
                            }
                            else {

                                proccess_Read = "Not read by any process."
                            }

                            if(thisFile.writes.length != 0){
                                thisFile.writes.forEach(function(process){
                                    proccess_Write += process + "<br/>"

                                });
                            }
                            else {

                                proccess_Write = "Not written by any process."
                            }

                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .8);
                            tooltip.html(
                                "<h5>From Package:  " +  thisFile.package+ " </h5>" +

                                "<h5>Read By: </h5>" +
                                proccess_Read
                                +
                                "<br>"
                                +
                                "<h5>Written By: </h5>" +
                                proccess_Write

                            )
                                .style("left", (d3.event.pageX) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");

                        })
                        .on("mouseout", function(d) {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        })
                        .text(fileName);

                    if(readsList[i+1] == null){

                        break;
                    }

                    if(readsList[i+1].includes(packagePath) == false ){


                        break;


                    }
                    i++;

                }


            }

        }
        else {
            readsFromDiv.append('details').append('summary').text("No associated file.");

        }


    }




    function createPackageTooTip(notes,source){



        var idString = "package_Div";

        var packageNames = source.packages.reads.sort().concat(source.packages.writes.sort());
        var packages = {};


        packageNames.forEach(function (package) {

            packages[package] = {["version"]:"", ["files"]:[]};

            forceData.packages.forEach(function(forceDataPackage){

                if(forceDataPackage.name == package && forceDataPackage.name != "other_files" ){

                    packages[package].version = "Version: " + forceDataPackage.version;
                }
            })


        });



        var fileList = source.reads.sort().concat(source.writes.sort());

        fileList.forEach(function(file){


            var keyName = "\"" + file + "\"";

            if(keyName in fileDict){


                var file = fileDict[keyName];

                packages[file.package].files.push(file);


            }


        });



        var readsFromDiv = notes.append('div').attr("id", idString ).attr("class", "panel-collapse ");


        var newDetails ;
        var newSummary;
        var currentUL ;


        console.log("packages details:", packages);
        // console.log("packages[package] after added files", Object.keys(packages).length);

        if(Object.keys(packages).length !=0){


            Object.keys(packages).forEach(function(key) {

                newDetails = readsFromDiv.append('details');
                newSummary = newDetails.append('summary').text(key);

                newSummary.on("mouseover", function(d) {

                    console.log("what is this d?:", d);


                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .8);
                    tooltip.html(
                        "<h5>" +  packages[key].version + " </h5>"

                    ).style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");


                }).on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });


                currentUL = newDetails.append('ul');

                packages[key].files.forEach(function (file) {

                    currentUL.append('li')
                        .text(file.name);

                })

            });


        }
        else {
            readsFromDiv.append('details').append('summary').text("No associated package.");

        }


    }




    function treeDraw(currentJsonFile){


        svg.selectAll(".package").remove();

        // d3.json block
        d3.json(currentJsonFile, function(error, data){

            if (error) throw error;

            var tempMaxRunTime = 0;





            data.packages.forEach(function (package) {

                package.files.forEach(function (file) {

                    var keyName = "\"" + file + "\"";

                    var fileInfo = [];
                    fileInfo["reads"] =[];
                    fileInfo["writes"] =[];
                    fileInfo["package"] = package.name;
                    fileInfo["name"] = file;

                    fileDict[keyName] = fileInfo;



                })
            });


            data.other_files.forEach(function (file) {


                var keyName = "\"" + file + "\"";

                var fileInfo = [];
                fileInfo["reads"] =[];
                fileInfo["writes"] =[];
                fileInfo["package"] ='other_files';
                fileInfo["name"] = file;

                fileDict[keyName] = fileInfo;


            });



            data.runs.forEach(function (run) {

                run.processes.forEach(function(_process) {


                    if(_process.reads != null){

                        _process.reads.forEach(function(file){

                            var keyName = "\"" + file + "\"";



                            if( keyName in fileDict){

                                //console.log('filesDict[file]:', filesDict[keyName]);

                                fileDict[keyName].reads.push(_process.long_name);

                            }

                        });

                    };


                    if (_process.writes != null){
                        _process.writes.forEach(function(file){



                            var keyName = "\"" + file + "\"";

                            if(keyName in fileDict){


                                fileDict[keyName].writes.push(_process.long_name);

                            }


                        });
                    }


                })


            });


            var tempPackageX = 0;
            var tempPackageY = 30;
            var isAlternativeOn = 0;

            //Handle Packages to create force data
            data.packages.forEach(function (package) {


                var thisPackage = {["name"]: package.name, ["version"]: package.version, ["files"] : [] , ["cx"]: 0, ["cy"]: tempPackageY , ["OGy"]: tempPackageY, ["color"]: "" , ["radius"] : maxRadius};

                package.files.forEach(function (file) {


                    var keyName = "\"" + file + "\"";

                    var thisFile =  fileDict[keyName];
                    thisPackage.files.push(thisFile);

                    forceNodes.nodes.push(thisFile);

                });


                thisPackage.cx = tempPackageX;
                thisPackage.OGX = tempPackageX;

                //Dynamically set the distances between nodes by number of packages
                if(data.packages.length > 15){

                    tempPackageX = tempPackageX + ((width /2.25) / data.packages.length); // 200;
                }
                else {

                    tempPackageX = tempPackageX + (width / 4 / data.packages.length); // 200;
                }



                forceData.packages.push(thisPackage);

                //increase packagesNumber
                packagesNumber++;

                // set alternative Y position for force nodes
                if(isAlternativeOn == 0 && data.packages.length > 15){

                    tempPackageY = 80;

                    isAlternativeOn = 1;
                }
                else if (isAlternativeOn == 1){

                    tempPackageY = 30;
                    isAlternativeOn = 0;

                }




            });

            console.log('forceData:' , forceData);


            //Handle runs
            data.runs.forEach(function(run){

                run.processes.forEach(function(_process){

                    var packages = {["reads"]:[], ["writes"]: []};
                    var packagesName = [];

                    if(_process.parent == null){

                        var node = {["name"]: _process.long_name, ["parent"]: "null", ["rule"] : "null", ["description"]: _process.description, ["reads"]: _process.reads ,  ["writes"]: _process.writes  ,["argv"]: _process.argv  , ["start_time"] : _process.start_time , ["exit_time"] : _process.exit_time};


                        if(_process.reads != null){

                            _process.reads.forEach(function(file){

                                var keyName = "\"" + file + "\"";

                                if( keyName in fileDict){

                                    packages.reads.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }

                            });

                            let uniq = [...new Set(packages.reads)];
                            packages.reads = uniq;
                        };



                        if (_process.writes != null){
                            _process.writes.forEach(function(file){



                                var keyName = "\"" + file + "\"";

                                if(keyName in fileDict){

                                    packages.writes.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }


                            });

                            let uniq = [...new Set(packages.writes)];
                            packages.writes = uniq;
                        }

                        node.packages = packages;

                        let uniq = [...new Set(packagesName)];
                        node.packageNames = uniq;


                        if(_process.exit_time > tempMaxRunTime ){

                            tempMaxRunTime = _process.exit_time;
                        }

                        rawData.push(node);

                    }
                    else {

                        var parentProcess = run.processes[ ( _process.parent[0] ) ];

                        var node = {["name"]: _process.long_name, ["parent"]: parentProcess.long_name, ["rule"] : _process.parent[1], ["description"]: _process.description ,  ["reads"]: _process.reads ,  ["writes"]: _process.writes ,["argv"]: _process.argv , ["start_time"] : _process.start_time , ["exit_time"] : _process.exit_time};


                        // var filesDict = {} ;

                        if(_process.reads != null){

                            _process.reads.forEach(function(file){

                                var keyName = "\"" + file + "\"";

                                //console.log('Inner keyName:', fileDict[keyName]);
                                //console.log('keyName:', keyName);

                                if( keyName in fileDict){

                                    // console.log('filesDict[file] package Name:', fileDict[keyName].package);

                                    packages.reads.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);
                                    //filesDict[keyName].reads.push(_process.long_name);

                                }

                            });

                            let uniq = [...new Set(packages.reads)];
                            packages.reads = uniq;
                        };



                        if (_process.writes != null){
                            _process.writes.forEach(function(file){



                                var keyName = "\"" + file + "\"";

                                if(keyName in fileDict){

                                    packages.writes.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }


                            });

                            let uniq = [...new Set(packages.writes)];
                            packages.writes = uniq;
                        }

                        node.packages = packages;

                        let uniq = [...new Set(packagesName)];
                        node.packageNames = uniq;


                        if(_process.exit_time > tempMaxRunTime ){

                            tempMaxRunTime = _process.exit_time;
                        }

                        rawData.push(node);


                    }


                });

                console.log('rawData', rawData);


                var dataMap = rawData.reduce(function(map, node) {
                    map[node.name] = node;
                    return map;
                }, {});


                rawData.forEach(function(node) {
                    // add to parent
                    var parent = dataMap[node.parent];
                    if (parent) {
                        // create child array if it doesn't exist
                        (parent.children || (parent.children = []))
                        // add node to child array
                            .push(node);
                    } else {
                        // parent is null or missing
                        treeData.push(node);
                    }
                });


                console.log('treeData', treeData);


            });




            // Default timeline length for root
            function collapse(d) {

                if (d.children) {


                    if(isTreeRedrawn == false){
                        timeLineLen_Total =  timeLineLen_Total + (root.x0  / 2);

                    }


                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }


            }


            //Call Force Draw function
            forceDraw(forceData);


            //Time line code block
            root = treeData[0];
            root.x0 = height / 2;
            root.y0 = 0;

            rootStartTime = root.start_time;


            var duration_ms = (root.children[0].start_time - rootStartTime) / 1000000;

            var duration = new moment.duration(duration_ms);

            var durationLabel  = "Took " + duration.asMilliseconds().toFixed(2) + " milliseconds";


            duration_total_ms =  (tempMaxRunTime - rootStartTime) / 1000000 ;

            var durationLabel_total  = getTimeLineLabel(duration_total_ms,"total");


            // timeLineLen = root.x0 / 2;
            timeLineLen_Total = root.x0 / 2;


            root.children.forEach(collapse);

            //  console.log('timeLineLen_Total: ', timeLineLen_Total);

            timeLineLen =  timeLineLen_Total * (duration_ms / duration_total_ms);

            //   console.log('timeLineLen: ', timeLineLen);

            if(isTreeRedrawn == false){


                totalTimeLineDraw(timeLineLen_Total, durationLabel_total);
                timeLineDraw(timeLineLen, durationLabel);


            }
            else{

                updateTimeLine(timeLineLen,durationLabel);

            }



            update(root);

        })



    }

    function getTimeLineLabel(duration_ms, isTotalString){

        var duration_total = new moment.duration(duration_ms);

        var durationLabel_total  = '';


        if(duration_total.asMilliseconds() < 60000){

            durationLabel_total =  duration_total.asMilliseconds().toFixed(2) + " milliseconds";

        }
        else if (duration_total.asSeconds() < 60 && duration_total.asSeconds() > 0){

            durationLabel_total =  duration_total.asSeconds().toFixed(2) + " seconds";

        }

        else if (duration_total.asMinutes() < 60 && duration_total.asMinutes() > 0){

            durationLabel_total =  duration_total.asMinutes().toFixed(2) + " minutes"; //+ " and " + duration.asSeconds().toFixed(0) + " seconds";

        }
        else if (duration_total.asHours() < 24 && duration_total.asHours() > 0){

            durationLabel_total =   duration_total.asHours().toFixed(2) + " hours" ;

        }
        else if (duration_total.asDays() < 28 && duration_total.asDays() > 0){

            durationLabel_total =  duration_total.asDays().toFixed(2) + " days" ;

        }

        if (isTotalString == "total"){

            durationLabel_total = "Total " + durationLabel_total;
        }else{

            durationLabel_total = "Took " + durationLabel_total;
        }

        return durationLabel_total;


    }

    function timeLineDraw(length, durationLabel){

        //  Draw the timeline for currentduration
        var lines = svg.append("g")
            .attr("class", "timeLineGroup")
            .append("line")
            .attr("class", "timeLine")
            .attr("x1", 0)
            .attr("y1", height  )
            .attr("x2", length)
            .attr("y2", height )
            .attr("stroke-width", 5)
            .attr("stroke", "#dbbd5a");



        // Update the link text
        var timeLineText = svg.selectAll(".timeLineGroup").append("text")
            .attr("y", height + 20)//magic number here
            .attr("x", length / 2)
            .attr('text-anchor', 'middle')
            .attr("class", "timeLineText")//easy to style with CSS
            .text(durationLabel);



    }

    function totalTimeLineDraw(length, durationLabel){

        // Draw the timeline for total duration.
        var lines = svg.append("g")
            .attr("class", "TotalTimeLineGroup")
            .append("line")
            .attr("class", "timeLine_Total")
            .attr("x1", 0)
            .attr("y1", height )
            .attr("x2", length)
            .attr("y2", height )
            .attr("stroke-width", 5)
            .attr("stroke", "#5adbbd");



        // Update the link text
        var timeLineText = svg.selectAll(".TotalTimeLineGroup").append("text")
            .attr("y", height + 20)//magic number here
            .attr("x", length )
            .attr('text-anchor', 'middle')
            .attr("class", "totalTimeLineText")//easy to style with CSS
            .text(durationLabel);



    }


    function forceDraw(data) {


        var nodes = data.packages;



        force = d3.layout.force()
            .nodes(nodes)
            .size([width, height])
            .linkDistance(0)
            .gravity(0)
            .charge(0)
            .on("tick", tick);



        var links = force.links();

//
//        var node = {};
//        node.x = 100;
//        node.y = 100;
//        node.cx = 100;
//        node.cy = 100;
//        node.px = 100;
//        node.py = 100;
//        node.weight = 10;
//        node.style =
//            ("fill" , function() {
//                return "hsl(" + Math.random() * 360 + ",60%,80%)";
//            });
//        node.radius = 20;
//
//
//
//        var node2 = {};
//        node2.x = 100 + 100;
//        node2.y = 100 + 100 ;
//        node2.cx = 100 + 100;
//        node2.cy = 100 + 100 ;
//        node2.px = 100 + 100;
//        node2.py = 100 + 100;
//        node2.weight = 10;
//        node2.style =
//            ("fill" , function() {
//                return "hsl(" + Math.random() * 360 + ",60%,80%)";
//            });
//
//        node2.radius = 20;
//
//        var nodes = force.nodes();
//        nodes.push(node);
//        nodes.push(node2);
//
//        links.push({source: node, target: node2});
//
//
//        console.log('links:', links);
//        console.log('force.nodes():', force.nodes());



        var circle = svg.selectAll("circle")
            .data(nodes)
            .enter().append("circle")
            .attr("class", 'package')
            .attr("r", function (d) {
                return d.radius;
            })
            .style("fill",function() {
                return "hsl(" + Math.random() * 720 + ",55%,80%)";
            })
            .on("mouseover", function(d) {

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .8);
                tooltip .html(
                    d.name + "<br>" + "version: " + d.version
                )
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 38) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .call(force.drag);

        var label = svg.selectAll(".mytext")
            .data(nodes)
            .enter()
            .append("text")
            .text(function (d) { return d.name; })
            .style("text-anchor", "middle")
            .style("fill", "#555")
            .style("font-family", "Arial")
            .style("font-size", 15);

        edge.data(links).enter().insert("line", ".package")
            .attr("class", "edge")
            .attr("x1", function(d){ return d.source.x;
            })
            .attr("y1", function(d){ return d.source.y; })
            .attr("x2", function(d){ return d.target.x; })
            .attr("y2", function(d){ return d.target.y; });

        ///  var edge = svg.selectAll(".edge");


        //        var newforceNodes = force.nodes().push(node);
        //
        //
        //
        //
        //        force.nodes().forEach(function(target) {
        //
        //            d.packages.reads.forEach(function (readFile) {
        //
        //                if(target.name == readFile){
        //
        //
        //                    links.push({source: node, target: target});
        //                }
        //
        //            })
        //

        // console.log('restart before link: ', edge);




        restart();


        function restart() {

            edge = svg.selectAll(".edge");

            edge.data(links).enter().insert("line", ".package")
                .attr("class", "edge")
                .attr("x1", function(d){ return d.source.x;
                })
                .attr("y1", function(d){ return d.source.y; })
                .attr("x2", function(d){ return d.target.x; })
                .attr("y2", function(d){ return d.target.y; });


            force.start();
        }

        function tick(e) {

            edge.attr("x1", function(d){ console.log("mapping link"); return d.source.x;
            })
                .attr("y1", function(d){ return d.source.y; })
                .attr("x2", function(d){ return d.target.x; })
                .attr("y2", function(d){ return d.target.y; });


            circle
                .each(gravity(3 * e.alpha))
                .each(collide(.2))
                .attr("cx", function (d) {
                    return d.x;
                })
                .attr("cy", function (d) {
                    return d.y;
                });


            label.attr("x", function(d){ return d.x; })
                .attr("y", function (d) {return d.y - 30; });
        }


        // Move nodes toward cluster focus.
        function gravity(alpha) {
            return function (d) {
                d.y += (d.cy - d.y) * alpha;
                d.x += (d.cx - d.x) * alpha;
            };
        }


        // Resolve collisions between nodes.
        function collide(alpha) {
            var quadtree = d3.geom.quadtree(nodes);
            return function (d) {
                var r = d.radius + maxRadius + padding,
                    nx1 = d.x - r,
                    nx2 = d.x + r,
                    ny1 = d.y - r,
                    ny2 = d.y + r;
                quadtree.visit(function (quad, x1, y1, x2, y2) {
                    if (quad.point && (quad.point !== d)) {
                        var x = d.x - quad.point.x,
                            y = d.y - quad.point.y,
                            l = Math.sqrt(x * x + y * y),
                            r = d.radius + quad.point.radius + (d.color !== quad.point.color) * padding;
                        if (l < r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            quad.point.x += x;
                            quad.point.y += y;
                        }
                    }
                    return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                });
            };

        }
    }




    function updateTimeLine(length, durationLabel){

        var timeline =  svg.selectAll(".timeLine");

        timeline.transition()
            .attr("x2", length);


        var timeLineText = d3.selectAll(".timeLineText")
            .transition()
            .attr("x", timeLineLen / 2)
            .attr('text-anchor', 'middle')
            .attr("class", "timeLineText")//easy to style with CSS

            .text(durationLabel);





    }


    function decreaseTimeLineLen(length){

        if((timeLineLen - ( length) >= 0)) {

            timeLineLen =  length //timeLineLen - ( length);
        }

    }

    function setPackagePath (fileList, index, nextIndex){

        // console.log('nextIndex: ', nextIndex);

        var TestingPackagePath = '';

        if(fileList[nextIndex] != null){


            a1_Len =  fileList[index].length;
            var i = 0;

            while(i < a1_Len && fileList[index].charAt(i)===fileList[nextIndex].charAt(i)){

                i++
            }

            if (fileList[index].substring(0,i) == '/'){


                // console.log('different character: ',fileList[index].substring(0,i));

                TestingPackagePath = fileList[index].substring(0, fileList[index].lastIndexOf('/'));
                //  console.log('TestingPackagePath: ',TestingPackagePath);

            }
            else {


                TestingPackagePath = fileList[index].substring(0,i);
                TestingPackagePath = TestingPackagePath.substring(0, TestingPackagePath.lastIndexOf('/'));
                // console.log('TestingPackagePath: ',TestingPackagePath);

            }


        }
        else {

            TestingPackagePath = fileList[index].substring(0, fileList[index].lastIndexOf('/'));

        }

        return TestingPackagePath;

    }

</script>


</body>