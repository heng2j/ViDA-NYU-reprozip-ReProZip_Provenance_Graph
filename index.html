<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<body>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

<link href="https://gitcdn.github.io/bootstrap-toggle/2.2.2/css/bootstrap-toggle.min.css" rel="stylesheet">
<script src="https://gitcdn.github.io/bootstrap-toggle/2.2.2/js/bootstrap-toggle.min.js"></script>
<script src="https://cdn.rawgit.com/eligrey/canvas-toBlob.js/f1a01896135ab378aa5c0118eadd81da55e698d8/canvas-toBlob.js"></script>
<script src="https://cdn.rawgit.com/eligrey/FileSaver.js/e9d941381475b5df8b7d7691013401e171014e89/FileSaver.min.js"></script>
<script src="https://momentjs.com/downloads/moment.js"></script>
<link rel="stylesheet" href="style.css">

<!-- Planing to switch to d3 v4 if necessary
<script src="https://d3js.org/d3.v4.min.js"></script>
-->
<script src="//d3js.org/d3.v3.min.js"></script>


<div id="mySidenav" class="sidenav">
    <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>


    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title" style="margin-left: -25px; font-size: 24px;">
                <a data-toggle="collapse" data-parent="#accordion" href="#collapse1">Overview</a>
            </h4>
        </div>

        <div id="collapse1" class="panel-collapse collapse">


            <div class="panel-body">
                <div>
                    <button id='saveButton'>Export to PNG</button>
                </div>
                <div>
                    <label>
                        <input id="toggle-inFocus" type="checkbox" data-toggle="toggle" >
                        Focus selected processes and packages
                    </label>
                </div>

                <div class="All_Packages">



                </div>


            </div>
        </div>
    </div>
    <div class="panel panel-default">
        <div class="panel-heading">
            <h4 class="panel-title" style="margin-left: -25px">
                <a data-toggle="collapse" data-parent="#accordion" href="#collapse2">Process Details</a>
            </h4>
        </div>
        <div id="collapse2" class="panel-collapse collapse in">
            <div >

                <div id='notes' class="fileSearch">

                    <h4 style="margin-top: 0px; font-size: 15px">Please select a process</h4>

                </div>

            </div>




        </div>



    </div>






</div>


<div id='container'>
    <div id='sidePanel'>

        <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; </span>
    </div>


    <div id='viz-graph'></div>

</div>

<script>
    $(function() {
        $('#toggle-inFocus').change(function() {

            inFocus = $(this).prop('checked');


        })
    })
</script>

<script>
    //script for Sidebar
    function openNav() {
        document.getElementById("mySidenav").style.width = "20%";
        document.getElementById("viz-graph").style.marginLeft = "20%";
    }

    function closeNav() {
        document.getElementById("mySidenav").style.width = "0";
        document.getElementById("viz-graph").style.marginLeft= "0";
    }
</script>


<script>

    // script to prepare data
    var fileDict = {};
    var rawData = [] ;
    var treeData = [];
    //  var forceNodes = {"nodes" : []};

</script>


<script>

    // script for visualization

    //var currentJsonFile = "bash-count.json";
    //var currentJsonFile = "stacked-up-website.json";
    var currentJsonFile = "ache.json";


    var availableJsonFiles = ["bash-count.json", "stacked-up-website.json", "ache.json"];

    var forceData = {"packages": []};

    var force = d3.layout.force();


    var inFocus;

    var packagesNumber = 0;

    var isTreeRedrawn = false;

    // add the tool tip
    var tooltip = d3.select("body").append("div")
        .attr("class", "tooltip")
        .style("opacity", 0);


    var margin = {top: 300, right: 120, bottom: 300, left: 150},
        width = 4500 - margin.right - margin.left,
        height = 1400 - margin.top - margin.bottom,
        padding = 3.5, // separation between same-color nodes
        maxRadius = 20 // radious for each package ;

    var timeLineLen;
    var timeLineLen_Total;
    var duration_total_ms;

    var searchFilesInfoDiv;
    var searchFilesList;


    var thisNodeCircle;
    var thisNodeCircleLabel;


    var i = 0,
        duration = 750,
        rootStartTime,
        root,
        m = 15; // number of distinct clusters;



    var tree = d3.layout.tree()
        .size([height , width ]);




    var diagonal = d3.svg.diagonal()
        .projection(function(d) { return [d.y, d.x]; });

    var svg = d3.select("#viz-graph").append("svg")
        .attr("width", width + margin.right + margin.left)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("class", "viz")
        .attr("id", "viz")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");



    // Select the container for the notes and dimension it.
    var notes = d3.select('#notes')
        .style({
            'width': 620-width + 'px',
            'height': height + 'px',
            'margin-top' : 25 + 'px'
        });

    var forceNodes; // = force.nodes();
    var forceLinks; // = force.links();
    var forcePackages = svg.selectAll(".package");
    var label = svg.selectAll(".forceLabel");
    var edge = svg.selectAll(".edge");





    treeDraw(currentJsonFile);



    //-- Click any empty space within the svg body to reset the location for the packages and detached the links between the packages and processes
    d3.select("body").on("click",function(){


        if (d3.event.target.toString().includes("SVGSVGElement")){

            console.log('clicked an empty space!');


            resetPackagesPosition();

        }


    });



    var select = d3.select('#jsonSelections')
        .append('select')
        .attr('class','select')
        .attr("x", 400)
        .on('change',function onchange() {
            selectValue = d3.select('select').property('value');

            currentJsonFile = selectValue;

            treeDraw(currentJsonFile);

            isTreeRedrawn = true;
        });


    var options = select
        .selectAll('option')
        .data(availableJsonFiles).enter()
        .append('option')
        .text(function (d) { return d; });

    d3.select(self.frameElement).style("height", "800px");


    // update Tree function
    function update(source) {



        // Compute the new tree layout.
        var nodes = tree.nodes(root).reverse(),
            links = tree.links(nodes);


        // Normalize for fixed-depth.
        nodes.forEach(function(d) { d.y = d.depth * 320;

        });

        // Update the nodesâ€¦
        var node = svg.selectAll("g.node")
            .data(nodes, function(d) { return d.id || (d.id = ++i); });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "translate(" + source.y0 + "," + source.x0 + ")"; })
            .on("dblclick", dblclick)
            .on("click", click)
            .on("mousedown", function(d){

                //  d3.select("body").transition().style("background-color", "#1c1c1c");



                // auto-show item content when show results reduces to single

//                ;( function( $, window, document, undefined )
//                {
//                    var $container = $( '.viz' );
//
//
//                    if( !$container.length ) return true;
//
//                    var $packages = $container.find( '.package' ),
//                        $package			= $();
//
//                    $input.on( 'keyup', function()
//                    {
//                        $item = $items.not( '.is-hidden' );
//                        if( $item.length == 1 )
//                            $item.addClass( 'js--autoshown is-active' );
//                        else
//                            $items.filter( '.js--autoshown' ).removeClass( 'js--autoshown is-active' );
//                    });
//                })( jQuery, window, document );

            })
            .on("mouseup", function(d){

                console.log("mouseUP");
                d3.select("body").transition().style("background-color", "white");

            })
            .on("mouseover", function(d) {

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .8);
                tooltip .html(
                    d.description
                )
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 38) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });




        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .attr("class", "process")
            .attr("id",  function(d) { return "process_" + d.name.replace(/[ ()]/g,''); })
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeEnter.append("text")
            .attr("class", "processLabel")
            .attr("id",  function(d) { return "processLabel_" + d.name.replace(/[ ()]/g,''); })
            .attr("x", function(d) { return d.children || d._children ? -10 : 10; })
            .attr("dy", ".35em")
            .attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; })
            .text(function(d) { return d.name; })
            .style("fill-opacity", 1e-6);


        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function(d) {



                return "translate(" + d.y + "," + d.x + ")"; });

        nodeUpdate.select("circle")
            .attr("r", 8)
            .style("fill", function(d) { return d._children ? "lightsteelblue" : "#fff"; });

        nodeUpdate.select("text")
            .style("fill-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function(d) { return "translate(" + source.y + "," + source.x + ")"; })
            .remove();

        nodeExit.select("circle")
            .attr("r", 1e-6);

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);

        // Update the linksâ€¦
        var link = svg.selectAll("path.link")
            .data(links, function(d) { return d.target.id; });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function(d) {
                var o = {x: source.x0, y: source.y0};
                return diagonal({source: o, target: o});
            });


        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function(d) {
                var o = {x: source.x, y: source.y};
                return diagonal({source: o, target: o});
            })
            .remove();


        // Update the link text
        var linktext = svg.selectAll("g.link")
            .data(links, function (d) {
                return d.target.id;
            });

        //  console.log('linktext',linktext);


        linktext.enter()
            .insert("g")
            .attr("class", "link")
            .attr("transform", function(d) { return "translate(" + d.source.y + "," + d.source.x + ")"; })
            .append("text")
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .style("font-size", 15)
            .text(function (d) {
                return d.target.rule;
            });

        // Transition link text to their new positions

        linktext.transition()
            .duration(duration)
            .attr("transform", function (d) {
                return "translate(" + ((d.source.y + d.target.y) / 2) + "," + ((d.source.x + d.target.x) / 2) + ")";
            })


        //Transition exiting link text to the parent's new position.
        linktext.exit().transition()
            .remove();


        // Stash the old positions for transition.
        nodes.forEach(function(d) {
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

    // Toggle children on click.
    function dblclick(d) {



        var links = force.links();

        links = [];

        edge = svg.selectAll(".edge").data(links);

        var edgeExit = edge.exit().remove();
        var circles = svg.selectAll("circle");


        forceLinks = links;

        force.links(links);

        restart();





        var duration;

        if (d.children) {


            d._children = d.children;
            d.children = null;

            decreaseTimeLineLen(d.y );

            console.log('Close');

            duration = (d.start_time - rootStartTime) / 1000000;


        } else {


            d.children = d._children;
            d._children = null;

            console.log('Open');



            var tempDuration = 0;


            if (d.children != null){

                d.children.forEach(function(node) {

                    if ((node.start_time - rootStartTime) > tempDuration) {

                        tempDuration = node.start_time - rootStartTime;
                    };


                });
            }
            else{
                tempDuration = d.exit_time - rootStartTime;

            }


            duration = tempDuration / 1000000;  //d.children[0].start_time - rootStartTime;


        }

        timeLineLen =  timeLineLen_Total * (duration / duration_total_ms);

        //  var durationLabel  = "Took " + (duration / 1000000).toFixed(2) + " milliseconds";

        updateTimeLine(timeLineLen, getTimeLineLabel(duration));



        update(d);


    }


    // Toggle children on click.
    function click(d) {


        console.log('single click');

        console.log('This D: ', d);

        console.log('This this: ', this);


        if(inFocus == true){

            var otherSVG = d3.selectAll(".process, .processLabel, .package, .edge, .packageLabel, .link");

            otherSVG.style("opacity", 0.3);

        }


//       var thisProcess = d3.selectAll(".process")
//            .style("opacity",
//                function() {
//
//
//                    return (this === selectedMethod) ? 1.0 : 0.2;
//
//
//                }
//            );




        console.log("otherSVG: ", otherSVG);



        if (thisNodeCircle != null && thisNodeCircleLabel != null){


            thisNodeCircle.transition().attr("r", 8);
            thisNodeCircleLabel.transition().style("font", "15px sans-serif").attr("x", function(d) { return d.children || d._children ? -10 : 10; });


        }



        thisNodeCircle = d3.select("#process_"+ d.name.replace(/[ ()]/g,''));// d3.select("id","#process_" + d.name.replace(/[ ()]/g,''));
        thisNodeCircleLabel = d3.select("#processLabel_"+ d.name.replace(/[ ()]/g,''));// d3.select("id","#process_" + d.name.replace(/[ ()]/g,''));


        thisNodeCircle.transition().attr("r", 20).style("opacity", 1);
        thisNodeCircleLabel
            .transition()
            .style("font", "20px sans-serif")
            .style("opacity", 1)
            .attr("x", function(d) { return d.children || d._children ? -30 : 30; });




        // var thisEdge = d3.select("#edge_" +package.name);



        var isFadeItems = svg.selectAll(".is-focus");

        console.log("isFadeItems", isFadeItems);





        var links = force.links();




        links = [];
        //edge = [];


        edge = svg.selectAll(".edge").data(links);



        var edgeExit = edge.exit().remove();

        if(forceNodes.length > packagesNumber){

            forceNodes.pop();


        }





        // add links to any nearby nodes

        var node = {};
        node.x = d.y;
        node.y = d.x;
        node.px = d.y;
        node.py = d.x;
        node.weight = 10;
        node.style =
            ("fill" , function() {
                return "hsl(" + Math.random() * 360 + ",60%,80%)";
            });
        node.radius = 20;
        node.fixed = true;



        thisNode  = forceNodes.push(node);


        var circles = svg.selectAll("circle");



        forceNodes.forEach(function(target) {

            d.packages.reads.forEach(function (readFile) {

                if(target.name == readFile){


                    console.log("target.name: ",target.name );
                    console.log("readFile: ", readFile.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,"") );


                    d3.select("#package_" + readFile.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,"")).style("opacity", 1);
                    d3.select("#packageLabel_" + readFile.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,"")).style("opacity", 1);

                    links.push({source: node, target: target});

                }

            })



        });



        forceLinks = links;




        var label = svg.selectAll(".forceLabel")
            .data(force.nodes());

        label.attr("x", function(d){ return d.x; })
            .attr("y", function (d) {return d.y - 30; });

        force.links(links);
        //force.nodes(thisNode);

        console.log("circles before Enter", svg.selectAll(".package"));

//       svg.selectAll(".package").data(force.nodes()).enter().append("circle").attr("r", 5)
//            .call(force.drag);

//        circlesEnter.attr("cx", function(d) { return d.x; })
//            .attr("cy", function(d) { return d.y; });
//
//        console.log("circlesEnter", circlesEnter);

        restart();






        // Delete the current notes section to prepare
        // for new information.

        notes.selectAll('*').remove();

        var commands = '';


        if(d.argv != null){

            d.argv.forEach(function(argv){

                commands += argv;//.concat(argv.toString());
                commands += ' ';

            });
        }
        else{

            commands = 'No argument for this process'
        }


        // Fill in the notes section with informationm
        // from the node. Because we want to transition
        // this to match the transitions on the graph,
        // we first set it's opacity to 0.

        notes.style({'opacity': 0});
        // Now add the notes content.


        var fileNames = d.reads.sort().concat(d.writes.sort());
        let uniqFileNames = [...new Set(fileNames)];


        //  var readFromDivHeader = notes.append('div').attr("id", "readFromDivHeader").attr("class", "panel-heading");
        notes.append('h3').text("Process:").attr("href", "#ProcessName").attr("class", "panel-title").attr("data-toggle", "collapse").style({'padding-left': 0, 'font-size': '24px','text-decoration': 'none', 'color':'black' });
        notes.append('h5').text(d.name).attr("id", "ProcessName" ).attr("class", "panel-collapse "); //.style({'padding-left': 0, 'text-decoration': 'none', 'color':'black' });


        notes.append('h3').text("Commands:").attr("href", "#Commands").attr("class", "panel-title").attr("data-toggle", "collapse").style({'padding-left': 0, 'font-size': '24px','text-decoration': 'none', 'color':'black' });
        notes.append('h5').text(commands).attr("id", "Commands" ).attr("class", "panel-collapse ");

        notes.append('h3').text("Associated Files:").style({'padding-left': 0, 'text-decoration': 'none' ,'color':'black'});
        notes.append('h6').text(uniqFileNames.length + " files");
        notes.append('input').attr("type", "search").attr("class", "fileSearch_input").attr("placeholder", "Search for listing files")
            .style("margin-left", "10px;");

        searchFilesInfoDiv = notes.append('div').attr("class", "searchFilesInfoDiv");

        searchFilesList = notes.append('div').attr("class", "searchFilesList");


        var filesList = [];

        var fileNamesList = d.reads.sort().concat(d.writes.sort());

        fileNamesList.forEach(function(file){


            var keyName = "\"" + file + "\"";

            if(keyName in fileDict){


                var file = fileDict[keyName];

                filesList.push(file);

            }


        });



        var filelistUL = searchFilesList.append('ul');
        var fileCount = 1;

        filesList.forEach(function(file){

            var id = "faq-" + fileCount;
            var href = "#" + id;

            var fileLi =   filelistUL.append('li').attr("id",id );

            var fileH2 =  fileLi.append('h4');//.text(file.name);
            var fileA =  fileH2.append('a').attr("href", href).text(file.name);

            var fileDiv = fileLi.append('div');



            var proccess_Read = "";
            var proccess_Write = "";


            if(file.reads.length != 0){
                file.reads.forEach(function(process){
                    proccess_Read += process + "<br/>"

                });
            }
            else {

                proccess_Read = "Not read by any process."
            }

            if(file.writes.length != 0){
                file.writes.forEach(function(process){
                    proccess_Write += process + "<br/>"

                });
            }
            else {

                proccess_Write = "Not written by any process."
            }

            fileDiv.html(
                "<br>" +
                "<h5>From Package:  " +  file.package+ " </h5>" +

                "<h5>Read By: </h5>" +
                proccess_Read
                +
                "<br>"
                +
                "<h5>Written By: </h5>" +
                proccess_Write

            )



            fileCount++;

        });


        searchFilesList.append('div').attr("class", "searchFilesList__notfound").html(
            "<p>No matches were found&hellip; Try &ldquo;bash&rdquo;.</p>"

        );


        // associationString: "reads" or  "writes
        createFileTooTip(searchFilesInfoDiv,d,"reads");
        createFileTooTip(searchFilesInfoDiv,d,"writes");



        var packageNames = d.packages.reads.sort().concat(d.packages.writes.sort());
        let uniqPackageNames = [...new Set(packageNames)];



        searchFilesInfoDiv.append('h3').text("Associated Packages:").style({'padding-left': 0, 'text-decoration': 'none' ,'color':'black'});
        searchFilesInfoDiv.append('h6').text(uniqPackageNames.length + " packages");

        createPackageTooTip(searchFilesInfoDiv,d);



        // With the content in place, transition
        // the opacity to make it visible.

        notes.transition().style({'opacity': 1});


        // 'use strict';


        // search & highlight
        ;( function( $, window, document, undefined )
        {
            var $container = $( '.fileSearch' );
            var $searchFilesListContainer = $container.find( '.searchFilesList' );

            if( !$container.length ) return true;


            var $input			= $container.find( '.fileSearch_input' ),
                $notfound		= $searchFilesListContainer.find( '.searchFilesList__notfound' ),
                $items			= $searchFilesListContainer.find( '> ul > li' ),
                $item			= $(),
                itemsIndexed	= [];

            console.log("searchFilesListContainer:", $searchFilesListContainer);


            $items.each( function()
            {
                itemsIndexed.push( $( this ).text().replace( /\s{2,}/g, ' ' ).toLowerCase() );
            });

            $input.on( 'keyup', function( e )
            {
                console.log('keyup : ');

                $(".searchFilesInfoDiv").hide();
                $(".searchFilesList").show();


                if( e.keyCode == 13 ) // enter
                {

                    $input.trigger( 'blur' );
                    return true;
                }

                $items.each( function()
                {
                    $item = $( this );
                    $item.html( $item.html().replace( /<span class="highlight">([^<]+)<\/span>/gi, '$1' ) );
                });

                var searchVal = $.trim( $input.val() ).toLowerCase();
                if( searchVal.length )
                {
                    for( var i in itemsIndexed )
                    {
                        $item = $items.eq( i );
                        if( itemsIndexed[ i ].indexOf( searchVal ) != -1 )
                            $item.removeClass( 'is-hidden' ).html( $item.html().replace( new RegExp( searchVal+'(?!([^<]+)?>)', 'gi' ), '<span class="highlight">$&</span>' ) );
                        else
                            $item.addClass( 'is-hidden' );
                    }
                }
                else {
                    $items.removeClass('is-hidden');

                    $(".searchFilesInfoDiv").show();
                    $(".searchFilesList").hide();

                }

                $notfound.toggleClass( 'is-visible', $items.not( '.is-hidden' ).length == 0 );
            });
        })( jQuery, window, document );


        // toggling items on title press

        ;( function( $, window, document, undefined )
        {
            $( document ).on( 'click', '.searchFilesList h4 a', function( e )
            {
                e.preventDefault();
                $( this ).parents( 'li' ).toggleClass( 'is-active' );
            });
        })( jQuery, window, document );


        // auto-show item content when show results reduces to single

        ;( function( $, window, document, undefined )
        {
            var $container = $( '.fileSearch' );
            var $searchFilesListContainer = $container.find( '.searchFilesList' );

            if( !$container.length ) return true;

            var $input			= $container.find( '.fileSearch_input' ),
                $items			= $searchFilesListContainer.find( '> ul > li' ),
                $item			= $();

            $input.on( 'keyup', function()
            {
                $item = $items.not( '.is-hidden' );
                if( $item.length == 1 )
                    $item.addClass( 'js--autoshown is-active' );
                else
                    $items.filter( '.js--autoshown' ).removeClass( 'js--autoshown is-active' );
            });
        })( jQuery, window, document );



    }


    function createFileTooTip(notesDiv,source, associationString){


        var readsList;
        var idString;
        var idString_href;
        var text_String ;

        if(associationString == 'reads'){

            idString = "readsToDiv";
            idString_href = "#readsToDiv";
            text_String = "Reads from:";
            readsList = source.reads.sort();
        }
        else if (associationString == 'writes'){

            idString = "writesToDiv";
            idString_href = "#writesToDiv";
            text_String = "Writes to:";
            readsList = source.writes.sort();

        }



        notesDiv.append('h5').attr("class", "panel-title").append('a').attr("data-toggle", "collapse").attr("href", idString_href).text(text_String).style({'padding-left': 0, 'text-decoration': 'none', 'font': '8 px sans-serif' });

        var readsFromDiv = notesDiv.append('div').attr("id", idString ).attr("class", "panel-collapse ");

        // var readsList = source.writes.sort();
        var packagePath = '';
        var newDetails ;
        var newSummary;
        var currentUL ;


        if(readsList.length !=0){

            for (var i = 0; i < readsList.length; i++ ){

                packagePath = setPackagePath(readsList, i , i + 1);
                newDetails = readsFromDiv.append('details');
                newSummary = newDetails.append('summary').text(packagePath);
                currentUL = newDetails.append('ul');

                while(readsList[i].includes(packagePath) ){


                    var thisReadArray = ["\"" + readsList[i] + "\""];

                    var fileName = readsList[i].replace(packagePath,"");

                    currentUL.append('li')
                        .data(thisReadArray)
                        .on("mouseover", function(d) {


                            var thisFile =  fileDict[d];

                            var proccess_Read = "";
                            var proccess_Write = "";


                            if(thisFile.reads.length != 0){
                                thisFile.reads.forEach(function(process){
                                    proccess_Read += process + "<br/>"

                                });
                            }
                            else {

                                proccess_Read = "Not read by any process."
                            }

                            if(thisFile.writes.length != 0){
                                thisFile.writes.forEach(function(process){
                                    proccess_Write += process + "<br/>"

                                });
                            }
                            else {

                                proccess_Write = "Not written by any process."
                            }

                            tooltip.transition()
                                .duration(200)
                                .style("opacity", .8);
                            tooltip.html(
                                "<h5>From Package:  " +  thisFile.package+ " </h5>" +

                                "<h5>Read By: </h5>" +
                                proccess_Read
                                +
                                "<br>"
                                +
                                "<h5>Written By: </h5>" +
                                proccess_Write

                            )
                                .style("left", (d3.event.pageX) + "px")
                                .style("top", (d3.event.pageY - 28) + "px");

                        })
                        .on("mouseout", function(d) {
                            tooltip.transition()
                                .duration(500)
                                .style("opacity", 0);
                        })
                        .text(fileName);

                    if(readsList[i+1] == null){

                        break;
                    }

                    if(readsList[i+1].includes(packagePath) == false ){


                        break;


                    }
                    i++;

                }


            }

        }
        else {
            readsFromDiv.append('details').append('summary').text("No associated file.");

        }


    }




    function createPackageTooTip(notes,source){


        console.log('createPackageTooTip source', source);

        var idString = "package_Div";

        var packageNames = source.packages.reads.sort().concat(source.packages.writes.sort());
        var packages = {};


        packageNames.forEach(function (package) {

            packages[package] = {["version"]:"", ["files"]:[]};

            forceData.packages.forEach(function(forceDataPackage){

                if(forceDataPackage.name == package && forceDataPackage.name != "other_files" ){

                    packages[package].version = "Version: " + forceDataPackage.version;
                }
            })


        });



        var fileList = source.reads.sort().concat(source.writes.sort());

        fileList.forEach(function(file){


            var keyName = "\"" + file + "\"";

            if(keyName in fileDict){


                var file = fileDict[keyName];

                packages[file.package].files.push(file);


            }


        });



        var readsFromDiv = notes.append('div').attr("id", idString ).attr("class", "panel-collapse ");


        var newDetails ;
        var newSummary;
        var currentUL ;
        var container;


        // console.log("packages[package] after added files", Object.keys(packages).length);

        if(Object.keys(packages).length !=0){


            Object.keys(packages).forEach(function(key) {


                var summaryText = "";
                if(packages[key].files.length > 1){

                    summaryText = key + "    (" +  packages[key].files.length + " files)";
                }
                else {

                    summaryText = key + "    (" +  packages[key].files.length + " file)";
                }


                container = readsFromDiv.append('div');

//
//                var checkBox =  container.append("foreignObject")
//                    .attr("width", 100)
//                    .attr("height", 100)
//                    .style("float", 'left')
//                    .style("margin-left", 30)
//                    .append("xhtml:body")
//                    .html("<form><input type=checkbox id=check /></form>")
//                    .on("click", function(d, i){
//
//                        console.log(" theck box d:", d);
//                        console.log(" the source:", source);
//                       // console.log(svg.select("#check").node().checked);
//
//
//                    });


                newDetails = container.append('details');
                newSummary = newDetails.append('summary').text(summaryText);

                newSummary.on("mouseover", function(d) {


                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .8);
                    tooltip.html(
                        "<h5>" +  packages[key].version + " </h5>"

                    ).style("left", (d3.event.pageX) + "px")
                        .style("top", (d3.event.pageY - 28) + "px");


                }).on("mouseout", function(d) {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                });


                currentUL = newDetails.append('ul');

                packages[key].files.forEach(function (file) {

                    currentUL.append('li')
                        .text(file.name);

                })

            });


        }
        else {
            readsFromDiv.append('details').append('summary').text("No associated package.");

        }


    }

    function createAllPackageList(packages){

        //  var packages = {};


        var allPackageListDiv = d3.selectAll(".All_Packages");
        var mainContainer;


        allPackageListDiv.append('h3').text("All Packages:").attr("id", "AllPackagesDiv" ).attr("href", "#AllPackages").attr("class", "panel-title").attr("data-toggle", "collapse").style({'padding-left': 0, 'text-decoration': 'none' ,'color':'black'});
        // var readsFromDiv = notes.append('div').attr("id", idString ).attr("class", "panel-collapse ");
        mainContainer = allPackageListDiv.append('div').attr("id", "AllPackages" ).attr("class", "panel-collapse ");

        mainContainer.append('h6').text(packages.length + " packages");

        var newDetails ;
        var newSummary;
        var currentUL ;
        var subContainer;




        packages.forEach(function(package){

            //    packages[package.name] = {["version"]: package.version, ["files"]:package.files};

            var summaryText = "";

            if(package.files.length > 1){

                summaryText = package.name + "    (" +  package.files.length + " files)";
            }
            else {

                summaryText = package.name + "    (" +  package.files.length + " file)";
            }

            subContainer = mainContainer.append('div');

            var checkBox =  subContainer.append("input")
                .attr("type", "checkbox")
                .attr("width", 100)
                .attr("height", 100)
                .attr("checked", true)
                .style("float", 'left')
                .style("padding-left", 50)
                .on("click", function(d, i){


                    var thisPackage = d3.select("#package_" +package.name.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,""));
                    var thisEdge = d3.select("#edge_" +package.name.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,""));
                    var thisPackageLabel = d3.select("#packageLabel_" +package.name.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,""));



                    if(d3.select(this).node().checked == false){


                        thisPackage.style({
                            "opacity": 0

                        });

                        thisPackageLabel.style({
                            "opacity": 0

                        });

                        thisEdge.style({
                            "opacity": 0

                        });



                    }
                    else{

                        thisPackage.style({
                            "opacity": 1

                        });

                        thisPackageLabel.style({
                            "opacity": 1

                        });

                        thisEdge.style({
                            "opacity": 1

                        });


                    }



                });


            newDetails = subContainer.append('details');
            newSummary = newDetails.append('summary').text(summaryText);

            newSummary.on("mouseover", function(d) {


                tooltip.transition()
                    .duration(200)
                    .style("opacity", .8);
                tooltip.html(
                    "<h5>" + "Version: " + package.version + " </h5>"

                ).style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");


            }).on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            });


            currentUL = newDetails.append('ul');

            package.files.forEach(function (file) {

                currentUL.append('li')
                    .text(file.name);

            })


        })




    }


    function treeDraw(currentJsonFile){



        // d3.json block
        d3.json(currentJsonFile, function(error, data){

            if (error) throw error;

            var tempMaxRunTime = 0;





            data.packages.forEach(function (package) {

                package.files.forEach(function (file) {

                    var keyName = "\"" + file + "\"";

                    var fileInfo = [];
                    fileInfo["reads"] =[];
                    fileInfo["writes"] =[];
                    fileInfo["package"] = package.name;
                    fileInfo["name"] = file;

                    fileDict[keyName] = fileInfo;



                })
            });


            data.other_files.forEach(function (file) {


                var keyName = "\"" + file + "\"";

                var fileInfo = [];
                fileInfo["reads"] =[];
                fileInfo["writes"] =[];
                fileInfo["package"] ='other_files';
                fileInfo["name"] = file;

                fileDict[keyName] = fileInfo;


            });



            data.runs.forEach(function (run) {

                run.processes.forEach(function(_process) {


                    if(_process.reads != null){

                        _process.reads.forEach(function(file){

                            var keyName = "\"" + file + "\"";



                            if( keyName in fileDict){

                                //console.log('filesDict[file]:', filesDict[keyName]);

                                fileDict[keyName].reads.push(_process.long_name);

                            }

                        });

                    };


                    if (_process.writes != null){
                        _process.writes.forEach(function(file){



                            var keyName = "\"" + file + "\"";

                            if(keyName in fileDict){


                                fileDict[keyName].writes.push(_process.long_name);

                            }


                        });
                    }


                })


            });


            var tempPackageX = 0;
            var tempPackageY = -200;
            var isAlternativeOn = 0;

            //Handle Packages to create force data
            data.packages.forEach(function (package) {


                var thisPackage = {["name"]: package.name, ["version"]: package.version, ["files"] : [] , ["cx"]: 0, ["cy"]: tempPackageY , ["OGy"]: tempPackageY, ["color"]: "" , ["radius"] : maxRadius};

                package.files.forEach(function (file) {


                    var keyName = "\"" + file + "\"";

                    var thisFile =  fileDict[keyName];
                    thisPackage.files.push(thisFile);

                    // forceNodes.nodes.push(thisFile);

                });


                thisPackage.cx = tempPackageX;
                thisPackage.OGX = tempPackageX;

                //Dynamically set the distances between nodes by number of packages
                if(data.packages.length > 15 && data.packages.length < 30 ){

                    tempPackageX = tempPackageX + ((width /3) / data.packages.length); // 200;
                }
                else if(data.packages.length > 30){

                    tempPackageX = tempPackageX + ((width /1.8) / data.packages.length); // 200;
                }
                else {

                    tempPackageX = tempPackageX + (width / 4 / data.packages.length); // 200;
                }



                forceData.packages.push(thisPackage);

                //increase packagesNumber
                packagesNumber++;

                // set alternative Y position for force nodes
                if(isAlternativeOn == 0 && data.packages.length > 15){

                    tempPackageY = -120;

                    isAlternativeOn = 1;
                }
                else if (isAlternativeOn == 1){

                    tempPackageY = -200;
                    isAlternativeOn = 0;

                }




            });

            console.log('forceData:' , forceData);



            createAllPackageList(forceData.packages);

            //Handle runs
            data.runs.forEach(function(run){

                run.processes.forEach(function(_process){

                    var packages = {["reads"]:[], ["writes"]: []};
                    var packagesName = [];

                    if(_process.parent == null){

                        var node = {["name"]: _process.long_name, ["parent"]: "null", ["rule"] : "null", ["description"]: _process.description, ["reads"]: _process.reads ,  ["writes"]: _process.writes  ,["argv"]: _process.argv  , ["start_time"] : _process.start_time , ["exit_time"] : _process.exit_time};


                        if(_process.reads != null){

                            _process.reads.forEach(function(file){

                                var keyName = "\"" + file + "\"";

                                if( keyName in fileDict){

                                    packages.reads.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }

                            });

                            let uniq = [...new Set(packages.reads)];
                            packages.reads = uniq;
                        };



                        if (_process.writes != null){
                            _process.writes.forEach(function(file){



                                var keyName = "\"" + file + "\"";

                                if(keyName in fileDict){

                                    packages.writes.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }


                            });

                            let uniq = [...new Set(packages.writes)];
                            packages.writes = uniq;
                        }

                        node.packages = packages;

                        let uniq = [...new Set(packagesName)];
                        node.packageNames = uniq;


                        if(_process.exit_time > tempMaxRunTime ){

                            tempMaxRunTime = _process.exit_time;
                        }

                        rawData.push(node);

                    }
                    else {

                        var parentProcess = run.processes[ ( _process.parent[0] ) ];

                        var node = {["name"]: _process.long_name, ["parent"]: parentProcess.long_name, ["rule"] : _process.parent[1], ["description"]: _process.description ,  ["reads"]: _process.reads ,  ["writes"]: _process.writes ,["argv"]: _process.argv , ["start_time"] : _process.start_time , ["exit_time"] : _process.exit_time};


                        // var filesDict = {} ;

                        if(_process.reads != null){

                            _process.reads.forEach(function(file){

                                var keyName = "\"" + file + "\"";

                                //console.log('Inner keyName:', fileDict[keyName]);
                                //console.log('keyName:', keyName);

                                if( keyName in fileDict){

                                    // console.log('filesDict[file] package Name:', fileDict[keyName].package);

                                    packages.reads.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);
                                    //filesDict[keyName].reads.push(_process.long_name);

                                }

                            });

                            let uniq = [...new Set(packages.reads)];
                            packages.reads = uniq;
                        };



                        if (_process.writes != null){
                            _process.writes.forEach(function(file){



                                var keyName = "\"" + file + "\"";

                                if(keyName in fileDict){

                                    packages.writes.push(fileDict[keyName].package);
                                    packagesName.push(fileDict[keyName].package);

                                }


                            });

                            let uniq = [...new Set(packages.writes)];
                            packages.writes = uniq;
                        }

                        node.packages = packages;

                        let uniq = [...new Set(packagesName)];
                        node.packageNames = uniq;


                        if(_process.exit_time > tempMaxRunTime ){

                            tempMaxRunTime = _process.exit_time;
                        }

                        rawData.push(node);


                    }


                });

                console.log('rawData', rawData);


                var dataMap = rawData.reduce(function(map, node) {
                    map[node.name] = node;
                    return map;
                }, {});


                rawData.forEach(function(node) {
                    // add to parent
                    var parent = dataMap[node.parent];
                    if (parent) {
                        // create child array if it doesn't exist
                        (parent.children || (parent.children = []))
                        // add node to child array
                            .push(node);
                    } else {
                        // parent is null or missing
                        treeData.push(node);
                    }
                });


                console.log('treeData', treeData);


            });




            // Default timeline length for root
            function collapse(d) {

                if (d.children) {


                    if(isTreeRedrawn == false){
                        timeLineLen_Total =  timeLineLen_Total + (root.x0  / 2);

                    }


                    d._children = d.children;
                    d._children.forEach(collapse);
                    d.children = null;
                }


            }





            //Time line code block
            root = treeData[0];
            root.x0 = height; // / 2;
            root.y0 = 0;

            rootStartTime = root.start_time;


            var duration_ms = (root.children[0].start_time - rootStartTime) / 1000000;

            var duration = new moment.duration(duration_ms);

            var durationLabel  = "Took " + duration.asMilliseconds().toFixed(2) + " milliseconds";


            duration_total_ms =  (tempMaxRunTime - rootStartTime) / 1000000 ;

            var durationLabel_total  = getTimeLineLabel(duration_total_ms,"total");


            // timeLineLen = root.x0 / 2;
            timeLineLen_Total = root.x0 / 2;


            root.children.forEach(collapse);

            //  console.log('timeLineLen_Total: ', timeLineLen_Total);

            timeLineLen =  timeLineLen_Total * (duration_ms / duration_total_ms);

            //   console.log('timeLineLen: ', timeLineLen);

            if(isTreeRedrawn == false){


                totalTimeLineDraw(timeLineLen_Total, durationLabel_total);
                timeLineDraw(timeLineLen, durationLabel);


            }
            else{

                updateTimeLine(timeLineLen,durationLabel);

            }



            update(root);

            //Call Force Draw function
            forceDraw(forceData);

            // createPackageTooTip(searchFilesInfoDiv,d);

        })



    }

    function getTimeLineLabel(duration_ms, isTotalString){

        var duration_total = new moment.duration(duration_ms);

        var durationLabel_total  = '';


        if(duration_total.asMilliseconds() < 60000){

            durationLabel_total =  duration_total.asMilliseconds().toFixed(2) + " milliseconds";

        }
        else if (duration_total.asSeconds() < 60 && duration_total.asSeconds() > 0){

            durationLabel_total =  duration_total.asSeconds().toFixed(2) + " seconds";

        }

        else if (duration_total.asMinutes() < 60 && duration_total.asMinutes() > 0){

            durationLabel_total =  duration_total.asMinutes().toFixed(2) + " minutes"; //+ " and " + duration.asSeconds().toFixed(0) + " seconds";

        }
        else if (duration_total.asHours() < 24 && duration_total.asHours() > 0){

            durationLabel_total =   duration_total.asHours().toFixed(2) + " hours" ;

        }
        else if (duration_total.asDays() < 28 && duration_total.asDays() > 0){

            durationLabel_total =  duration_total.asDays().toFixed(2) + " days" ;

        }

        if (isTotalString == "total"){

            durationLabel_total = "Total " + durationLabel_total;
        }else{

            durationLabel_total = "Took " + durationLabel_total;
        }

        return durationLabel_total;


    }

    function timeLineDraw(length, durationLabel){

        //  Draw the timeline for currentduration
        var lines = svg.append("g")
            .attr("class", "timeLineGroup")
            .append("line")
            .attr("class", "timeLine")
            .attr("x1", 0)
            .attr("y1", height  )
            .attr("x2", length)
            .attr("y2", height )
            .attr("stroke-width", 5)
            .attr("stroke", "#dbbd5a");



        // Update the link text
        var timeLineText = svg.selectAll(".timeLineGroup").append("text")
            .attr("y", height + 20)//magic number here
            .attr("x", length / 2)
            .attr('text-anchor', 'middle')
            .attr("class", "timeLineText")//easy to style with CSS
            .text(durationLabel);



    }

    function totalTimeLineDraw(length, durationLabel){

        // Draw the timeline for total duration.
        var lines = svg.append("g")
            .attr("class", "TotalTimeLineGroup")
            .append("line")
            .attr("class", "timeLine_Total")
            .attr("x1", 0)
            .attr("y1", height )
            .attr("x2", length)
            .attr("y2", height )
            .attr("stroke-width", 5)
            .attr("stroke", "#5adbbd");



        // Update the link text
        var timeLineText = svg.selectAll(".TotalTimeLineGroup").append("text")
            .attr("y", height + 20)//magic number here
            .attr("x", length )
            .attr('text-anchor', 'middle')
            .attr("class", "totalTimeLineText")//easy to style with CSS
            .text(durationLabel);



    }

    function restart() {


        edge = edge.data(forceLinks);

        edge.enter().insert("line", ".package")
            .attr("class", "edge")
            .attr("id",  function(d){
                return  "edge_" + d.target.name})
            .attr("x1", function(d){ return d.source.x;
            })
            .attr("y1", function(d){ return d.source.y; })
            .attr("x2", function(d){ return d.target.x; })
            .attr("y2", function(d){ return d.target.y; });

//
//        forcePackages = forcePackages.data(forceNodes);
//        forcePackages
//            .attr("cx", function (d) {
//
//                  console.log(("d.x: " , d.x));
//                return d.x;
//            })
//            .attr("cy", function (d) {
//                return d.y;
//            });



//        label = label.data(forceNodes);
//        label.attr("x", function(d){ return d.x; })
//            .attr("y", function (d) {return d.y - 30; });

        force.start();
    }



    // Move nodes toward cluster focus.
    function gravity(alpha) {
        return function (d) {
            d.y += (d.cy - d.y) * alpha;
            d.x += (d.cx - d.x) * alpha;
        };
    }


    // Resolve collisions between nodes.
    function collide(alpha) {
        var quadtree = d3.geom.quadtree(forceNodes);
        return function (d) {
            var r = d.radius + maxRadius + padding,
                nx1 = d.x - r,
                nx2 = d.x + r,
                ny1 = d.y - r,
                ny2 = d.y + r;
            quadtree.visit(function (quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== d)) {
                    var x = d.x - quad.point.x,
                        y = d.y - quad.point.y,
                        l = Math.sqrt(x * x + y * y),
                        r = d.radius + quad.point.radius + (d.color !== quad.point.color) * padding;
                    if (l < r) {
                        l = (l - r) / l * alpha;
                        d.x -= x *= l;
                        d.y -= y *= l;
                        quad.point.x += x;
                        quad.point.y += y;
                    }
                }
                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            });
        };

    }


    function tick(e) {

        edge.attr("x1", function(d){

            //console.log("mapping link");
            return d.source.x;
        })
            .attr("y1", function(d){ return d.source.y; })
            .attr("x2", function(d){ return d.target.x; })
            .attr("y2", function(d){ return d.target.y; });


        forcePackages
            .each(gravity(0.15 * e.alpha))
            .each(collide(0.2))
            .attr("cx", function (d) {

                //  console.log(("d.x: " , d.x));
                return d.x;
            })
            .attr("cy", function (d) {
                return d.y;
            });


        label.attr("x", function(d){ return d.x; })
            .attr("y", function (d) {return d.y - 30; });
    }

    function forceDraw(data) {


        var nodes = data.packages;


        force = d3.layout.force()
            .nodes(nodes)
            .size([ width, height])
            .linkDistance(300)
            .linkStrength(0.5)
            .gravity(0)
            .charge(-100)
            .on("tick", tick);


        forceNodes = force.nodes();
        forceLinks = force.links();

        console.log("the nodes: ", nodes);
        console.log("forceNodes: ", forceNodes );


        // var links = force.links();

//
//        var node = {};
//        node.x = 100;
//        node.y = 100;
//        node.cx = 100;
//        node.cy = 100;
//        node.px = 100;
//        node.py = 100;
//        node.weight = 2;
//        node.style =
//            ("fill" , function() {
//                return "hsl(" + Math.random() * 360 + ",60%,80%)";
//            });
//        node.radius = 20;
//
//
//
//        var node2 = {};
//        node2.x = 100 + 500;
//        node2.y = 100 + 500 ;
//        node2.cx = 100 + 500;
//        node2.cy = 100 + 500 ;
//        node2.px = 100 + 500;
//        node2.py = 100 + 500;
//        node2.weight = 1;
//        node2.style =
//            ("fill" , function() {
//                return "hsl(" + Math.random() * 360 + ",60%,80%)";
//            });
//
//        node2.radius = 20;
//
//        var nodes = force.nodes();
//        nodes.push(node);
//        nodes.push(node2);
//
//        links.push({source: node, target: node2});
//
//
//        console.log('links:', links);
//        console.log('force.nodes():', force.nodes());




        //   var circle = svg.selectAll(".package")


        // forcePackages
        // var circle = svg.selectAll(".package")
        forcePackages = forcePackages
            .data(forceNodes)
            .enter().append("circle")
            .attr("class", 'package')
            .attr("id", function(d){
                return "package_"+ d.name.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,"");

            })
            .attr("r", function (d) {
                return d.radius;
            })
            .style("fill",function() {
                return "hsl(" + Math.random() * 720 + ",55%,80%)";
            })
            .on("mouseover", function(d) {

                tooltip.transition()
                    .duration(200)
                    .style("opacity", .8);
                tooltip .html(
                    d.name + "<br>" + "version: " + d.version
                )
                    .style("left", (d3.event.pageX) + "px")
                    .style("top", (d3.event.pageY - 38) + "px");
            })
            .on("mouseout", function(d) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            })
            .call(force.drag);

        label = label
            .data(forceNodes)
            .enter()
            .append("text")
            .text(function (d) { return d.name; })
            .attr("class", "packageLabel")
            .attr("id", function (d) { return  "packageLabel_" + d.name.replace(/[.,\/#!$%\^&\*;:+{}=\-_`~()]/g,""); })
            .style("text-anchor", "middle")
            .style("fill", "#555")
            .style("font-family", "Arial")
            .style("font-size", 15);



//        edge.data(forceLinks).enter().insert("line", ".package")
//            .attr("class", "edge")
//            .attr("x1", function(d){ return d.source.x;
//            })
//            .attr("y1", function(d){ return d.source.y; })
//            .attr("x2", function(d){ return d.target.x; })
//            .attr("y2", function(d){ return d.target.y; });

        ///  var edge = svg.selectAll(".edge");


        //        var newforceNodes = force.nodes().push(node);
        //
        //
        //
        //
        //        force.nodes().forEach(function(target) {
        //
        //            d.packages.reads.forEach(function (readFile) {
        //
        //                if(target.name == readFile){
        //
        //
        //                    links.push({source: node, target: target});
        //                }
        //
        //            })
        //

        // console.log('restart before link: ', edge);


        console.log('Initial links:', forceLinks);

        restart();






    }




    function updateTimeLine(length, durationLabel){

        var timeline =  svg.selectAll(".timeLine");

        timeline.transition()
            .attr("x2", length);


        var timeLineText = d3.selectAll(".timeLineText")
            .transition()
            .attr("x", timeLineLen / 2)
            .attr('text-anchor', 'middle')
            .attr("class", "timeLineText")//easy to style with CSS

            .text(durationLabel);





    }


    function decreaseTimeLineLen(length){

        if((timeLineLen - ( length) >= 0)) {

            timeLineLen =  length //timeLineLen - ( length);
        }

    }

    function setPackagePath (fileList, index, nextIndex){

        // console.log('nextIndex: ', nextIndex);

        var TestingPackagePath = '';

        if(fileList[nextIndex] != null){


            a1_Len =  fileList[index].length;
            var i = 0;

            while(i < a1_Len && fileList[index].charAt(i)===fileList[nextIndex].charAt(i)){

                i++
            }

            if (fileList[index].substring(0,i) == '/'){


                // console.log('different character: ',fileList[index].substring(0,i));

                TestingPackagePath = fileList[index].substring(0, fileList[index].lastIndexOf('/'));
                //  console.log('TestingPackagePath: ',TestingPackagePath);

            }
            else {


                TestingPackagePath = fileList[index].substring(0,i);
                TestingPackagePath = TestingPackagePath.substring(0, TestingPackagePath.lastIndexOf('/'));
                // console.log('TestingPackagePath: ',TestingPackagePath);

            }


        }
        else {

            TestingPackagePath = fileList[index].substring(0, fileList[index].lastIndexOf('/'));

        }

        return TestingPackagePath;

    }


    function resetPackagesPosition(){


        if (thisNodeCircle != null && thisNodeCircleLabel != null){


            thisNodeCircle.transition().attr("r", 8);
            thisNodeCircleLabel.transition().style("font", "15px sans-serif").attr("x", function(d) { return d.children || d._children ? -10 : 10; });


        }

        links = [];

        edge = svg.selectAll(".edge").data(links);

        var edgeExit = edge.exit().remove();
        var circles = svg.selectAll("circle");

        forceLinks = links;

        force.links(links);

        restart();
    }

</script>



<script>

    // Set-up the export button
    d3.select('#saveButton').on('click', function(){
        var svgString = getSVGString(svg.node());
        console.log(svgString);

        svgString2Image( svgString, 2*width, 2*height, 'png', save ); // passes Blob and filesize String to the callback

        function save( dataBlob, filesize ){
            saveAs( dataBlob, 'D3 vis exported to PNG.png' ); // FileSaver.js function
        }
    });

    // Below are the functions that handle actual exporting:
    // getSVGString ( svgNode ) and svgString2Image( svgString, width, height, format, callback )
    function getSVGString( svgNode ) {
        svgNode.setAttribute('xlink', 'http://www.w3.org/1999/xlink');
        var cssStyleText = getCSSStyles( svgNode );
        appendCSS( cssStyleText, svgNode );

        var serializer = new XMLSerializer();
        var svgString = serializer.serializeToString(svgNode);
        svgString = svgString.replace(/(\w+)?:?xlink=/g, 'xmlns:xlink='); // Fix root xlink without namespace
        svgString = svgString.replace(/NS\d+:href/g, 'xlink:href'); // Safari NS namespace fix

        return svgString;

        function getCSSStyles( parentElement ) {
            var selectorTextArr = [];

            // Add Parent element Id and Classes to the list
            selectorTextArr.push( '#'+parentElement.id );
            for (var c = 0; c < parentElement.classList.length; c++)
                if ( !contains('.'+parentElement.classList[c], selectorTextArr) )
                    selectorTextArr.push( '.'+parentElement.classList[c] );

            // Add Children element Ids and Classes to the list
            var nodes = parentElement.getElementsByTagName("*");
            for (var i = 0; i < nodes.length; i++) {
                var id = nodes[i].id;
                if ( !contains('#'+id, selectorTextArr) )
                    selectorTextArr.push( '#'+id );

                var classes = nodes[i].classList;
                for (var c = 0; c < classes.length; c++)
                    if ( !contains('.'+classes[c], selectorTextArr) )
                        selectorTextArr.push( '.'+classes[c] );
            }

            // Extract CSS Rules
            var extractedCSSText = "";
            for (var i = 0; i < document.styleSheets.length; i++) {
                var s = document.styleSheets[i];

                try {
                    if(!s.cssRules) continue;
                } catch( e ) {
                    if(e.name !== 'SecurityError') throw e; // for Firefox
                    continue;
                }

                var cssRules = s.cssRules;
                for (var r = 0; r < cssRules.length; r++) {
                    if ( contains( cssRules[r].selectorText, selectorTextArr ) )
                        extractedCSSText += cssRules[r].cssText;
                }
            }


            return extractedCSSText;

            function contains(str,arr) {
                return arr.indexOf( str ) === -1 ? false : true;
            }

        }

        function appendCSS( cssText, element ) {
            var styleElement = document.createElement("style");
            styleElement.setAttribute("type","text/css");
            styleElement.innerHTML = cssText;
            var refNode = element.hasChildNodes() ? element.children[0] : null;
            element.insertBefore( styleElement, refNode );
        }
    }


    function svgString2Image( svgString, width, height, format, callback ) {
        var format = format ? format : 'png';

        var imgsrc = 'data:image/svg+xml;base64,'+ btoa( unescape( encodeURIComponent( svgString ) ) ); // Convert SVG string to data URL

        var canvas = document.createElement("canvas");
        var context = canvas.getContext("2d");

        canvas.width = width;
        canvas.height = height;

        var image = new Image();
        image.onload = function() {
            context.clearRect ( 0, 0, width, height );
            context.drawImage(image, 0, 0, width, height);

            canvas.toBlob( function(blob) {
                var filesize = Math.round( blob.length/1024 ) + ' KB';
                if ( callback ) callback( blob, filesize );
            });


        };

        image.src = imgsrc;
    }


</script>


</body>